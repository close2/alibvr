\hypertarget{namespaceclock}{}\section{clock Namespace Reference}
\label{namespaceclock}\index{clock@{clock}}


This file uses {\ttfamily Timer0} to provide a system clock.  


\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classclock_1_1__Clock}{\+\_\+\+Clock}
\begin{DoxyCompactList}\small\item\em Initialization code and access to the \+\_\+clock variable. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\hypertarget{namespaceclock_ac435d838e47eaebdb967aebfeab78eae}{}\label{namespaceclock_ac435d838e47eaebdb967aebfeab78eae} 
typedef \+\_\+alibvr\+\_\+clock\+\_\+select\+::\+Clock\+Select \hyperlink{namespaceclock_ac435d838e47eaebdb967aebfeab78eae}{Clock\+Select}
\begin{DoxyCompactList}\small\item\em Export of {\ttfamily \+\_\+alibvr\+\_\+clock\+\_\+select\+::\+Clock\+Select} \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{namespaceclock_aa67adb0b2215c44a4a770b6c36cfe8a7}{}\label{namespaceclock_aa67adb0b2215c44a4a770b6c36cfe8a7} 
void {\bfseries Clock\+Irq\+Task} (\+\_\+irqs\+::\+Irq I)
\item 
\hypertarget{namespaceclock_ac68f79977567f2ffe11ea30631653dd8}{}\label{namespaceclock_ac68f79977567f2ffe11ea30631653dd8} 
{\footnotesize template$<$typename T $>$ }\\constexpr uint64\+\_\+t {\bfseries \+\_\+to64bit} (T v)
\item 
{\footnotesize template$<$uint32\+\_\+t Units, uint32\+\_\+t Factor, uint32\+\_\+t Prescale$>$ }\\constexpr uint32\+\_\+t \hyperlink{namespaceclock_ae4ee0d04356b216b1d04046c0e1b2d38}{units\+\_\+to\+\_\+time} ()
\begin{DoxyCompactList}\small\item\em Convert \char`\"{}units\char`\"{} to real time units. \end{DoxyCompactList}\item 
{\footnotesize template$<$uint32\+\_\+t Time, uint32\+\_\+t Factor, uint32\+\_\+t Prescale$>$ }\\constexpr uint32\+\_\+t \hyperlink{namespaceclock_ac6b5f264784ea96fd8629fec0c0f7131}{time\+\_\+to\+\_\+units} ()
\begin{DoxyCompactList}\small\item\em Convert real time units to \char`\"{}units\char`\"{}. \end{DoxyCompactList}\item 
{\footnotesize template$<$uint32\+\_\+t Factor, uint32\+\_\+t Prescale = (uint32\+\_\+t) \+\_\+alibvr\+\_\+clock\+\_\+prescale\+::\+Prescale, typename T  = uint16\+\_\+t$>$ }\\\hyperlink{namespaceclock_aaadef4e91948a79985a42ebbd57fe2d1}{\+\_\+\+\_\+attribute\+\_\+\+\_\+} ((deprecated(\char`\"{}If possible use the template version.  \char`\"{} \char`\"{}This function probably bloats your code and might be very slow\char`\"{}))) inline uint32\+\_\+t \hyperlink{namespaceclock_ae4ee0d04356b216b1d04046c0e1b2d38}{units\+\_\+to\+\_\+time}(const T \&units)
\begin{DoxyCompactList}\small\item\em Convert \char`\"{}units\char`\"{} to real time units. \end{DoxyCompactList}\item 
{\footnotesize template$<$Clock\+Select P = \+\_\+alibvr\+\_\+clock\+\_\+prescale\+::\+Prescale, typename T  = uint16\+\_\+t$>$ }\\\hyperlink{namespaceclock_ad835387e001884a66a0c3538ab172505}{\+\_\+\+\_\+attribute\+\_\+\+\_\+} ((deprecated(\char`\"{}If possible use the template version.  \char`\"{} \char`\"{}This function probably bloats your code and might be very slow\char`\"{}))) inline T \hyperlink{namespaceclock_ae159a2e83f7b30eeafe3d5be8a3f5ef6}{ms\+\_\+to\+\_\+units}(const T \&n)
\begin{DoxyCompactList}\small\item\em Convert ms to \char`\"{}units\char`\"{}. \end{DoxyCompactList}\item 
{\footnotesize template$<$uint32\+\_\+t Time, Clock\+Select P = \+\_\+alibvr\+\_\+clock\+\_\+prescale\+::\+Prescale$>$ }\\constexpr uint32\+\_\+t \hyperlink{namespaceclock_ae159a2e83f7b30eeafe3d5be8a3f5ef6}{ms\+\_\+to\+\_\+units} ()
\begin{DoxyCompactList}\small\item\em Convert ms to \char`\"{}units\char`\"{}. \end{DoxyCompactList}\item 
{\footnotesize template$<$uint32\+\_\+t Time, Clock\+Select P = \+\_\+alibvr\+\_\+clock\+\_\+prescale\+::\+Prescale$>$ }\\constexpr uint32\+\_\+t \hyperlink{namespaceclock_a058555acfdfbc406daf1cb9331b0bc6f}{us\+\_\+to\+\_\+units} ()
\begin{DoxyCompactList}\small\item\em Convert µs to \char`\"{}units\char`\"{}. \end{DoxyCompactList}\item 
{\footnotesize template$<$uint32\+\_\+t Units, Clock\+Select P = \+\_\+alibvr\+\_\+clock\+\_\+prescale\+::\+Prescale$>$ }\\constexpr uint32\+\_\+t \hyperlink{namespaceclock_a475b3551d89e7a345492a61f70830bd8}{units\+\_\+to\+\_\+ms} ()
\begin{DoxyCompactList}\small\item\em Convert \char`\"{}units\char`\"{} to ms. \end{DoxyCompactList}\item 
{\footnotesize template$<$uint32\+\_\+t Units, Clock\+Select P = \+\_\+alibvr\+\_\+clock\+\_\+prescale\+::\+Prescale$>$ }\\constexpr uint32\+\_\+t \hyperlink{namespaceclock_a320b3614df868e901b2f022f70a3d8ae}{units\+\_\+to\+\_\+us} ()
\begin{DoxyCompactList}\small\item\em Convert \char`\"{}units\char`\"{} to µs. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename U $>$ }\\constexpr uint8\+\_\+t \hyperlink{namespaceclock_a2818f7b058e27771426f39c7aa0365cd}{duration\+\_\+passed} (const T \&previous\+\_\+clock, const T \&current\+\_\+clock, const U \&duration)
\begin{DoxyCompactList}\small\item\em Calculate if the difference between previous\+\_\+clock and current\+\_\+clock is bigger than duration. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename U $>$ }\\constexpr uint8\+\_\+t \hyperlink{namespaceclock_a4db26a90b5c001f2bb46af7a2069d63d}{duration\+\_\+passed} (const T \&previous\+\_\+clock, const U \&duration)
\begin{DoxyCompactList}\small\item\em Calculate if duration has passed since previous\+\_\+clock. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\static uint8\+\_\+t \hyperlink{namespaceclock_a107ad02a77763be28bf63d43c566cf75}{clock\+\_\+reached} (const T \&clock, const T \&previous\+\_\+clock, const T \&target\+\_\+clock)
\begin{DoxyCompactList}\small\item\em Calculate if target system clock has been reached. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\static uint8\+\_\+t \hyperlink{namespaceclock_aae7a34ec30a2420b2b51e717ab02c400}{clock\+\_\+reached} (const T \&previous\+\_\+clock, const T \&target\+\_\+clock)
\begin{DoxyCompactList}\small\item\em Calculate if target system clock has been reached. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\static uint8\+\_\+t \hyperlink{namespaceclock_a240d81de9119f92701aa5f26555972c4}{clock\+\_\+reached} (const T \&target\+\_\+clock)
\begin{DoxyCompactList}\small\item\em Calculate if target system clock has been reached. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
volatile \hyperlink{unionbits64__s}{bits64\+\_\+t} \hyperlink{namespaceclock_a0cfce972d3684eddb3dd61bb0baaf225}{\+\_\+clock}
\begin{DoxyCompactList}\small\item\em This is the system clock. \end{DoxyCompactList}\item 
\hypertarget{namespaceclock_a8414359d2fd2b9f75143850c0e3bb4b5}{}\label{namespaceclock_a8414359d2fd2b9f75143850c0e3bb4b5} 
static \hyperlink{classclock_1_1__Clock}{\+\_\+\+Clock} {\bfseries Clock}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
This file uses {\ttfamily Timer0} to provide a system clock. 

By default class related classes, enums,... are defined inside the {\ttfamily clock} namespace. If this creates a name clash with your code you may modify the namespace name by setting A\+L\+I\+B\+V\+R\+\_\+\+N\+A\+M\+E\+S\+P\+A\+C\+E\+\_\+\+C\+L\+O\+CK or A\+L\+I\+B\+V\+R\+\_\+\+N\+A\+M\+E\+S\+P\+A\+C\+E\+\_\+\+P\+R\+E\+F\+IX. The system clock is derived from the I\+O-\/clock and must be converted to seconds.

Conversion functions are provided. Try to stay with the template versions, which can be calculated during compile time. Conversion of variables (with values unknown during compile time) will probably include division code, which is both big and slow.

It is usually possible to compare the difference of 2 time instances with a converted interval value\+:

Instead of (both examples in pseudocode)\+:


\begin{DoxyCode}
uint8\_t clock1 = Clock;
\textcolor{comment}{// do something}
uint8\_t duration = Clock - clock1;
\textcolor{keywordflow}{if} (\hyperlink{namespaceclock_a475b3551d89e7a345492a61f70830bd8}{units\_to\_ms}(duration) > 5) \textcolor{comment}{// work took more than 5 ms}
\end{DoxyCode}


write


\begin{DoxyCode}
uint8\_t clock1 = Clock;
\textcolor{comment}{// do something}
uint8\_t duration = Clock - clock1;
\textcolor{keywordflow}{if} (duration > ms\_to\_units<5>()) \textcolor{comment}{// work took more than 5 ms}
\end{DoxyCode}


{\itshape Global irqs are enabled unless the macro\+: {\ttfamily A\+L\+I\+B\+V\+R\+\_\+\+C\+L\+O\+C\+K\+\_\+\+N\+O\+\_\+\+G\+L\+O\+B\+A\+L\+\_\+\+I\+RQ} or {\ttfamily A\+L\+I\+B\+V\+R\+\_\+\+N\+O\+\_\+\+G\+L\+O\+B\+A\+L\+\_\+\+I\+RQ} is defined!} By including this header directly or indirectly global irqs are enabled because of a static constructor in this file!

The clock is incremented inside the {\ttfamily Timer0} overflow irq handler. To activate the registered irq handler add {\ttfamily \#include R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+I\+R\+QS} after your {\ttfamily main} section. 

\subsection{Function Documentation}
\hypertarget{namespaceclock_aaadef4e91948a79985a42ebbd57fe2d1}{}\label{namespaceclock_aaadef4e91948a79985a42ebbd57fe2d1} 
\index{clock@{clock}!\+\_\+\+\_\+attribute\+\_\+\+\_\+@{\+\_\+\+\_\+attribute\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+attribute\+\_\+\+\_\+@{\+\_\+\+\_\+attribute\+\_\+\+\_\+}!clock@{clock}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+attribute\+\_\+\+\_\+()}{\_\_attribute\_\_()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$uint32\+\_\+t Factor, uint32\+\_\+t Prescale = (uint32\+\_\+t) \+\_\+alibvr\+\_\+clock\+\_\+prescale\+::\+Prescale, typename T  = uint16\+\_\+t$>$ \\
clock\+::\+\_\+\+\_\+attribute\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{(deprecated(\char`\"{}If possible use the template version.  \char`\"{} \char`\"{}This function probably bloats your code and might be very slow\char`\"{}))}]{ }\end{DoxyParamCaption}) const}



Convert \char`\"{}units\char`\"{} to real time units. 

Convert real time units to \char`\"{}units\char`\"{}.

\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000001}{Deprecated}]Use template versions if possible.\end{DoxyRefDesc}


See units\+\_\+to\+\_\+ms and units\+\_\+to\+\_\+us for functions with simplified input.


\begin{DoxyParams}{Parameters}
{\em units} & The system clock units, which should be converted. \\
\hline
\end{DoxyParams}

\begin{DoxyTemplParams}{Template Parameters}
{\em Factor} & Use 1 second / Factor as return unit. 1\textquotesingle{}000 for ms 1\textquotesingle{}000\textquotesingle{}000 for µs. \\
\hline
{\em Prescale} & The prescale for {\ttfamily Timer0}. \\
\hline
{\em T} & The type of units (automatically determined).\\
\hline
\end{DoxyTemplParams}
\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000002}{Deprecated}]Use template versions if possible.\end{DoxyRefDesc}


See units\+\_\+to\+\_\+ms and units\+\_\+to\+\_\+us for functions with simplified input.


\begin{DoxyParams}{Parameters}
{\em n} & The time duration, which should be converted. \\
\hline
\end{DoxyParams}

\begin{DoxyTemplParams}{Template Parameters}
{\em Factor} & Use 1 second / Factor as input unit. 1\textquotesingle{}000 for ms 1\textquotesingle{}000\textquotesingle{}000 for µs. \\
\hline
{\em Prescale} & The prescale for {\ttfamily Timer0}. \\
\hline
{\em T} & The type of units (automatically determined). \\
\hline
\end{DoxyTemplParams}
\hypertarget{namespaceclock_ad835387e001884a66a0c3538ab172505}{}\label{namespaceclock_ad835387e001884a66a0c3538ab172505} 
\index{clock@{clock}!\+\_\+\+\_\+attribute\+\_\+\+\_\+@{\+\_\+\+\_\+attribute\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+attribute\+\_\+\+\_\+@{\+\_\+\+\_\+attribute\+\_\+\+\_\+}!clock@{clock}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+attribute\+\_\+\+\_\+()}{\_\_attribute\_\_()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$Clock\+Select P = \+\_\+alibvr\+\_\+clock\+\_\+prescale\+::\+Prescale, typename T  = uint16\+\_\+t$>$ \\
clock\+::\+\_\+\+\_\+attribute\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{(deprecated(\char`\"{}If possible use the template version.  \char`\"{} \char`\"{}This function probably bloats your code and might be very slow\char`\"{}))}]{ }\end{DoxyParamCaption}) const}



Convert ms to \char`\"{}units\char`\"{}. 

Convert \char`\"{}units\char`\"{} to µs.

Convert \char`\"{}units\char`\"{} to ms.

Convert µs to \char`\"{}units\char`\"{}.

\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000003}{Deprecated}]Use template versions if possible.\end{DoxyRefDesc}



\begin{DoxyParams}{Parameters}
{\em n} & The time duration in ms, which should be converted. \\
\hline
\end{DoxyParams}

\begin{DoxyTemplParams}{Template Parameters}
{\em P} & The prescale for {\ttfamily Timer0}. \\
\hline
{\em T} & The type of units (automatically determined).\\
\hline
\end{DoxyTemplParams}
\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000004}{Deprecated}]Use template versions if possible.\end{DoxyRefDesc}



\begin{DoxyParams}{Parameters}
{\em n} & The time duration in µs, which should be converted. \\
\hline
\end{DoxyParams}

\begin{DoxyTemplParams}{Template Parameters}
{\em P} & The prescale for {\ttfamily Timer0}. \\
\hline
{\em T} & The type of units (automatically determined).\\
\hline
\end{DoxyTemplParams}
\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000005}{Deprecated}]Use template versions if possible.\end{DoxyRefDesc}



\begin{DoxyParams}{Parameters}
{\em units} & The time duration in units, which should be converted. \\
\hline
\end{DoxyParams}

\begin{DoxyTemplParams}{Template Parameters}
{\em P} & The prescale for {\ttfamily Timer0}. \\
\hline
{\em T} & The type of units (automatically determined).\\
\hline
\end{DoxyTemplParams}
\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000006}{Deprecated}]Use template versions if possible.\end{DoxyRefDesc}



\begin{DoxyParams}{Parameters}
{\em units} & The time duration in units, which should be converted. \\
\hline
\end{DoxyParams}

\begin{DoxyTemplParams}{Template Parameters}
{\em P} & The prescale for {\ttfamily Timer0}. \\
\hline
{\em T} & The type of units (automatically determined). \\
\hline
\end{DoxyTemplParams}
\hypertarget{namespaceclock_a107ad02a77763be28bf63d43c566cf75}{}\label{namespaceclock_a107ad02a77763be28bf63d43c566cf75} 
\index{clock@{clock}!clock\+\_\+reached@{clock\+\_\+reached}}
\index{clock\+\_\+reached@{clock\+\_\+reached}!clock@{clock}}
\subsubsection{\texorpdfstring{clock\+\_\+reached()}{clock\_reached()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
static uint8\+\_\+t clock\+::clock\+\_\+reached (\begin{DoxyParamCaption}\item[{const T \&}]{clock,  }\item[{const T \&}]{previous\+\_\+clock,  }\item[{const T \&}]{target\+\_\+clock }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Calculate if target system clock has been reached. 

In order for this function to work correctly the type of target\+\_\+clock (which is a template argument) must be big enough\+:

{\itshape the type of target\+\_\+clock must be big enough to represent {\ttfamily previous\+\_\+clock -\/ clock}.}

The previous\+\_\+clock is necessary because all clock operations assume that the system clock may wrap.

clock\+\_\+reached uses the same type for the system clock as the type of target\+\_\+clock (which is a template argument).

The previous\+\_\+clock argument allows us to determine if the system clock has wrapped. If the system clock is smaller than previous\+\_\+clock wrapping has occured.

Notice that target\+\_\+clock may also be a wrapped value. This means that target\+\_\+clock may be smaller than previous\+\_\+clock.

Simply imagine an infinite time line. To get a specific time instance, take the value modulo the size of the target\+\_\+clock type.

For instance the system clock value 300 and the target\+\_\+clock type uint8\+\_\+t would result in {\ttfamily 300 \% 256}, which is 44.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & The type size used for clock comparisons. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em clock} & The system clock value we should compare target to. \\
\hline
{\em previous\+\_\+clock} & Used to disambiguate wrapped clock values. (See function description.) \\
\hline
{\em target\+\_\+clock} & The target system clock value. \\
\hline
\end{DoxyParams}
\hypertarget{namespaceclock_aae7a34ec30a2420b2b51e717ab02c400}{}\label{namespaceclock_aae7a34ec30a2420b2b51e717ab02c400} 
\index{clock@{clock}!clock\+\_\+reached@{clock\+\_\+reached}}
\index{clock\+\_\+reached@{clock\+\_\+reached}!clock@{clock}}
\subsubsection{\texorpdfstring{clock\+\_\+reached()}{clock\_reached()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
static uint8\+\_\+t clock\+::clock\+\_\+reached (\begin{DoxyParamCaption}\item[{const T \&}]{previous\+\_\+clock,  }\item[{const T \&}]{target\+\_\+clock }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Calculate if target system clock has been reached. 

This function uses the current system clock as clock value.

In order for this function to work correctly the type of target\+\_\+clock (which is a template argument) must be big enough\+:

{\itshape the type of target\+\_\+clock must be big enough to represent {\ttfamily previous\+\_\+clock -\/ clock}.}

The previous\+\_\+clock is necessary because all clock operations assume that the system clock may wrap.

clock\+\_\+reached uses the same type for the system clock as the type of target\+\_\+clock (which is a template argument).

The previous\+\_\+clock argument allows us to determine if the system clock has wrapped. If the system clock is smaller than previous\+\_\+clock wrapping has occured.

Notice that target\+\_\+clock may also be a wrapped value. This means that target\+\_\+clock may be smaller than previous\+\_\+clock.

Simply imagine an infinite time line. To get a specific time instance, take the value modulo the size of the target\+\_\+clock type.

For instance the system clock value 300 and the target\+\_\+clock type uint8\+\_\+t would result in {\ttfamily 300 \% 256}, which is 44.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & The type size used for clock comparisons. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em previous\+\_\+clock} & Used to disambiguate wrapped clock values. (See function description.) \\
\hline
{\em target\+\_\+clock} & The target system clock value. \\
\hline
\end{DoxyParams}
\hypertarget{namespaceclock_a240d81de9119f92701aa5f26555972c4}{}\label{namespaceclock_a240d81de9119f92701aa5f26555972c4} 
\index{clock@{clock}!clock\+\_\+reached@{clock\+\_\+reached}}
\index{clock\+\_\+reached@{clock\+\_\+reached}!clock@{clock}}
\subsubsection{\texorpdfstring{clock\+\_\+reached()}{clock\_reached()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
static uint8\+\_\+t clock\+::clock\+\_\+reached (\begin{DoxyParamCaption}\item[{const T \&}]{target\+\_\+clock }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Calculate if target system clock has been reached. 

This function uses the current system clock as clock value and the current clock minus half the size of T as previous\+\_\+clock.

E.\+g. if T is uint8\+\_\+t the current system clock minus 128 is used as previous clock.

In order for this function to work correctly the type of target\+\_\+clock (which is a template argument) must be big enough\+:

{\itshape the type of target\+\_\+clock must be big enough to represent {\ttfamily previous\+\_\+clock -\/ clock}.}

The previous\+\_\+clock is necessary because all clock operations assume that the system clock may wrap.

clock\+\_\+reached uses the same type for the system clock as the type of target\+\_\+clock (which is a template argument).

The previous\+\_\+clock argument allows us to determine if the system clock has wrapped. If the system clock is smaller than previous\+\_\+clock wrapping has occured.

Notice that target\+\_\+clock may also be a wrapped value. This means that target\+\_\+clock may be smaller than previous\+\_\+clock.

Simply imagine an infinite time line. To get a specific time instance, take the value modulo the size of the target\+\_\+clock type.

For instance the system clock value 300 and the target\+\_\+clock type uint8\+\_\+t would result in {\ttfamily 300 \% 256}, which is 44.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & The type size used for clock comparisons. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em target\+\_\+clock} & The target system clock value. \\
\hline
\end{DoxyParams}
\hypertarget{namespaceclock_a2818f7b058e27771426f39c7aa0365cd}{}\label{namespaceclock_a2818f7b058e27771426f39c7aa0365cd} 
\index{clock@{clock}!duration\+\_\+passed@{duration\+\_\+passed}}
\index{duration\+\_\+passed@{duration\+\_\+passed}!clock@{clock}}
\subsubsection{\texorpdfstring{duration\+\_\+passed()}{duration\_passed()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T , typename U $>$ \\
constexpr uint8\+\_\+t clock\+::duration\+\_\+passed (\begin{DoxyParamCaption}\item[{const T \&}]{previous\+\_\+clock,  }\item[{const T \&}]{current\+\_\+clock,  }\item[{const U \&}]{duration }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Calculate if the difference between previous\+\_\+clock and current\+\_\+clock is bigger than duration. 

This function will return a correct result, even if Clock has wrapped around. It is however up to the caller to make sure that the clock type T is big enough.

Unless you have multiple comparisons with different durations, use the simpler duration\+\_\+passed function, which only requires previous\+\_\+clock.


\begin{DoxyParams}{Parameters}
{\em previous\+\_\+clock} & The clock value (in \char`\"{}units\char`\"{}) to which duration is added. It is ok if previous\+\_\+clock equals current\+\_\+clock. \\
\hline
{\em current\+\_\+clock} & The clock value (in \char`\"{}units\char`\"{}) which should be farther in the future than previous\+\_\+clock + duration for this function to return true. \\
\hline
{\em duration} & The duration in \char`\"{}units\char`\"{} which should pass since previous\+\_\+clock. See ms\+\_\+to\+\_\+units and us\+\_\+to\+\_\+units. \\
\hline
\end{DoxyParams}
\hypertarget{namespaceclock_a4db26a90b5c001f2bb46af7a2069d63d}{}\label{namespaceclock_a4db26a90b5c001f2bb46af7a2069d63d} 
\index{clock@{clock}!duration\+\_\+passed@{duration\+\_\+passed}}
\index{duration\+\_\+passed@{duration\+\_\+passed}!clock@{clock}}
\subsubsection{\texorpdfstring{duration\+\_\+passed()}{duration\_passed()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , typename U $>$ \\
constexpr uint8\+\_\+t clock\+::duration\+\_\+passed (\begin{DoxyParamCaption}\item[{const T \&}]{previous\+\_\+clock,  }\item[{const U \&}]{duration }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Calculate if duration has passed since previous\+\_\+clock. 

This function will return a correct result, even if Clock has wrapped around. It is however up to the caller to make sure that the clock type T is big enough.


\begin{DoxyParams}{Parameters}
{\em previous\+\_\+clock} & The clock value (in \char`\"{}units\char`\"{}) to which duration is added. It is ok if previous\+\_\+clock is the current Clock\+: {\ttfamily uint16\+\_\+t prev = Clock; while (!duration\+\_\+passed(prev, duration)) prev = Clock;} \\
\hline
{\em duration} & The duration in \char`\"{}units\char`\"{} which should pass since previous\+\_\+clock. See ms\+\_\+to\+\_\+units and us\+\_\+to\+\_\+units. \\
\hline
\end{DoxyParams}
\hypertarget{namespaceclock_ae159a2e83f7b30eeafe3d5be8a3f5ef6}{}\label{namespaceclock_ae159a2e83f7b30eeafe3d5be8a3f5ef6} 
\index{clock@{clock}!ms\+\_\+to\+\_\+units@{ms\+\_\+to\+\_\+units}}
\index{ms\+\_\+to\+\_\+units@{ms\+\_\+to\+\_\+units}!clock@{clock}}
\subsubsection{\texorpdfstring{ms\+\_\+to\+\_\+units()}{ms\_to\_units()}}
{\footnotesize\ttfamily template$<$uint32\+\_\+t Time, Clock\+Select P = \+\_\+alibvr\+\_\+clock\+\_\+prescale\+::\+Prescale$>$ \\
constexpr uint32\+\_\+t clock\+::ms\+\_\+to\+\_\+units (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Convert ms to \char`\"{}units\char`\"{}. 

See units\+\_\+to\+\_\+time for an explaination why inputs are template arguments and why this isn\textquotesingle{}t a constexpr function.


\begin{DoxyTemplParams}{Template Parameters}
{\em Time} & The time duration in ms, which should be converted. \\
\hline
{\em P} & The prescale for {\ttfamily Timer0}. \\
\hline
\end{DoxyTemplParams}
\hypertarget{namespaceclock_ac6b5f264784ea96fd8629fec0c0f7131}{}\label{namespaceclock_ac6b5f264784ea96fd8629fec0c0f7131} 
\index{clock@{clock}!time\+\_\+to\+\_\+units@{time\+\_\+to\+\_\+units}}
\index{time\+\_\+to\+\_\+units@{time\+\_\+to\+\_\+units}!clock@{clock}}
\subsubsection{\texorpdfstring{time\+\_\+to\+\_\+units()}{time\_to\_units()}}
{\footnotesize\ttfamily template$<$uint32\+\_\+t Time, uint32\+\_\+t Factor, uint32\+\_\+t Prescale$>$ \\
constexpr uint32\+\_\+t clock\+::time\+\_\+to\+\_\+units (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Convert real time units to \char`\"{}units\char`\"{}. 

See units\+\_\+to\+\_\+time for an explaination why inputs are template arguments and why this isn\textquotesingle{}t a constexpr function.

See ms\+\_\+to\+\_\+units and us\+\_\+to\+\_\+units for functions with simplified input.


\begin{DoxyTemplParams}{Template Parameters}
{\em Time} & The time duration, which should be converted. \\
\hline
{\em Factor} & Use 1 second / Factor as input unit. 1\textquotesingle{}000 for ms 1\textquotesingle{}000\textquotesingle{}000 for µs. \\
\hline
{\em Prescale} & The prescale for {\ttfamily Timer0}. \\
\hline
\end{DoxyTemplParams}
\hypertarget{namespaceclock_a475b3551d89e7a345492a61f70830bd8}{}\label{namespaceclock_a475b3551d89e7a345492a61f70830bd8} 
\index{clock@{clock}!units\+\_\+to\+\_\+ms@{units\+\_\+to\+\_\+ms}}
\index{units\+\_\+to\+\_\+ms@{units\+\_\+to\+\_\+ms}!clock@{clock}}
\subsubsection{\texorpdfstring{units\+\_\+to\+\_\+ms()}{units\_to\_ms()}}
{\footnotesize\ttfamily template$<$uint32\+\_\+t Units, Clock\+Select P = \+\_\+alibvr\+\_\+clock\+\_\+prescale\+::\+Prescale$>$ \\
constexpr uint32\+\_\+t clock\+::units\+\_\+to\+\_\+ms (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Convert \char`\"{}units\char`\"{} to ms. 

See units\+\_\+to\+\_\+time for an explaination why inputs are template arguments and why this isn\textquotesingle{}t a constexpr function.


\begin{DoxyTemplParams}{Template Parameters}
{\em Units} & The units which should be converted. \\
\hline
{\em P} & The prescale for {\ttfamily Timer0}. \\
\hline
\end{DoxyTemplParams}
\hypertarget{namespaceclock_ae4ee0d04356b216b1d04046c0e1b2d38}{}\label{namespaceclock_ae4ee0d04356b216b1d04046c0e1b2d38} 
\index{clock@{clock}!units\+\_\+to\+\_\+time@{units\+\_\+to\+\_\+time}}
\index{units\+\_\+to\+\_\+time@{units\+\_\+to\+\_\+time}!clock@{clock}}
\subsubsection{\texorpdfstring{units\+\_\+to\+\_\+time()}{units\_to\_time()}}
{\footnotesize\ttfamily template$<$uint32\+\_\+t Units, uint32\+\_\+t Factor, uint32\+\_\+t Prescale$>$ \\
constexpr uint32\+\_\+t clock\+::units\+\_\+to\+\_\+time (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Convert \char`\"{}units\char`\"{} to real time units. 

All inputs are template arguments. This makes sure that the compiler will be able to calculate everything during compile time.

This is also possible with {\ttfamily constexpr} functions. However as a {\ttfamily constexpr} will work with dynamic values as well and not give any warning I prefer the template version as it makes sure that the inputs are known during compile time.

See units\+\_\+to\+\_\+ms and units\+\_\+to\+\_\+us for functions with simplified input.


\begin{DoxyTemplParams}{Template Parameters}
{\em Units} & The system clock units, which should be converted. \\
\hline
{\em Factor} & Use 1 second / Factor as return unit. 1\textquotesingle{}000 for ms 1\textquotesingle{}000\textquotesingle{}000 for µs. \\
\hline
{\em Prescale} & The prescale for {\ttfamily Timer0}. \\
\hline
\end{DoxyTemplParams}
\hypertarget{namespaceclock_a320b3614df868e901b2f022f70a3d8ae}{}\label{namespaceclock_a320b3614df868e901b2f022f70a3d8ae} 
\index{clock@{clock}!units\+\_\+to\+\_\+us@{units\+\_\+to\+\_\+us}}
\index{units\+\_\+to\+\_\+us@{units\+\_\+to\+\_\+us}!clock@{clock}}
\subsubsection{\texorpdfstring{units\+\_\+to\+\_\+us()}{units\_to\_us()}}
{\footnotesize\ttfamily template$<$uint32\+\_\+t Units, Clock\+Select P = \+\_\+alibvr\+\_\+clock\+\_\+prescale\+::\+Prescale$>$ \\
constexpr uint32\+\_\+t clock\+::units\+\_\+to\+\_\+us (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Convert \char`\"{}units\char`\"{} to µs. 

See units\+\_\+to\+\_\+time for an explaination why inputs are template arguments and why this isn\textquotesingle{}t a constexpr function.


\begin{DoxyTemplParams}{Template Parameters}
{\em Units} & The units which should be converted. \\
\hline
{\em P} & The prescale for {\ttfamily Timer0}. \\
\hline
\end{DoxyTemplParams}
\hypertarget{namespaceclock_a058555acfdfbc406daf1cb9331b0bc6f}{}\label{namespaceclock_a058555acfdfbc406daf1cb9331b0bc6f} 
\index{clock@{clock}!us\+\_\+to\+\_\+units@{us\+\_\+to\+\_\+units}}
\index{us\+\_\+to\+\_\+units@{us\+\_\+to\+\_\+units}!clock@{clock}}
\subsubsection{\texorpdfstring{us\+\_\+to\+\_\+units()}{us\_to\_units()}}
{\footnotesize\ttfamily template$<$uint32\+\_\+t Time, Clock\+Select P = \+\_\+alibvr\+\_\+clock\+\_\+prescale\+::\+Prescale$>$ \\
constexpr uint32\+\_\+t clock\+::us\+\_\+to\+\_\+units (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Convert µs to \char`\"{}units\char`\"{}. 

See units\+\_\+to\+\_\+time for an explaination why inputs are template arguments and why this isn\textquotesingle{}t a constexpr function.


\begin{DoxyTemplParams}{Template Parameters}
{\em Time} & The time duration in µ, which should be converted. \\
\hline
{\em P} & The prescale for {\ttfamily Timer0}. \\
\hline
\end{DoxyTemplParams}


\subsection{Variable Documentation}
\hypertarget{namespaceclock_a0cfce972d3684eddb3dd61bb0baaf225}{}\label{namespaceclock_a0cfce972d3684eddb3dd61bb0baaf225} 
\index{clock@{clock}!\+\_\+clock@{\+\_\+clock}}
\index{\+\_\+clock@{\+\_\+clock}!clock@{clock}}
\subsubsection{\texorpdfstring{\+\_\+clock}{\_clock}}
{\footnotesize\ttfamily volatile \hyperlink{unionbits64__s}{bits64\+\_\+t} clock\+::\+\_\+clock}



This is the system clock. 

This variable is changed inside the {\ttfamily Timer0} overflow irq handler. {\ttfamily bits64\+\_\+t} is a union type providing easy access to all bytes.

The prescaler is by default set to 1/64.
\begin{DoxyItemize}
\item At 8\+M\+Hz \+\_\+clock is incremented every 2\textquotesingle{}048ns.
\item At 1\+M\+Hz \+\_\+clock is incremented every 16\textquotesingle{}384ns.
\end{DoxyItemize}

When retrieving the system clock the current {\ttfamily Timer0} counter is added. The precision of the system clock is therefore always cpu clock / prescaler. 