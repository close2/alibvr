\hypertarget{namespace__pulse__uart}{}\section{\+\_\+pulse\+\_\+uart Namespace Reference}
\label{namespace__pulse__uart}\index{\+\_\+pulse\+\_\+uart@{\+\_\+pulse\+\_\+uart}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{class__pulse__uart_1_1DoNothing}{Do\+Nothing}
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const uint32\+\_\+t {\bfseries Cpu} = 1000000\hypertarget{namespace__pulse__uart_a54a3816b5d606db8b8ca8bcb568eeb85}{}\label{namespace__pulse__uart_a54a3816b5d606db8b8ca8bcb568eeb85}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Transmission will usually be synchronous. Pulse \hyperlink{classUart}{Uart} has been implemented to achieve higher speeds. Transmission should therefore not take a lot of time and I\+R\+Qs would make an implementation probably much slower.

However the core transmission code can be used to transmit using I\+R\+Qs. (mini-\/tasks).

We have a function which returns in how many units it wants to be called again.

The synchronous version will busy wait. The I\+RQ version could use mini tasks.

Reception O\+T\+OH is probably always I\+RQ based.

Greatly inspired by \href{http://www.romanblack.com/RF/cheapRFmodules.htm}{\tt http\+://www.\+romanblack.\+com/\+R\+F/cheap\+R\+Fmodules.\+htm} 