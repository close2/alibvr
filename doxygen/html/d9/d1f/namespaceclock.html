<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>alibvr: clock Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">alibvr
   </div>
   <div id="projectbrief">An avr Atmega 328 library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">clock Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file uses <code>Timer0</code> to provide a system clock.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de9/classclock_1_1__Clock.html">_Clock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization code and access to the _clock variable.  <a href="../../d8/de9/classclock_1_1__Clock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac435d838e47eaebdb967aebfeab78eae"><td class="memItemLeft" align="right" valign="top"><a id="ac435d838e47eaebdb967aebfeab78eae"></a>
typedef _alibvr_clock_select::ClockSelect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d1f/namespaceclock.html#ac435d838e47eaebdb967aebfeab78eae">ClockSelect</a></td></tr>
<tr class="memdesc:ac435d838e47eaebdb967aebfeab78eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export of <code>_alibvr_clock_select::ClockSelect</code> <br /></td></tr>
<tr class="separator:ac435d838e47eaebdb967aebfeab78eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa67adb0b2215c44a4a770b6c36cfe8a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d1f/namespaceclock.html#aa67adb0b2215c44a4a770b6c36cfe8a7">ClockIrqTask</a> (_irqs::Irq I)</td></tr>
<tr class="memdesc:aa67adb0b2215c44a4a770b6c36cfe8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the Timer0 Overflow handler, which increments the system clock.  <a href="#aa67adb0b2215c44a4a770b6c36cfe8a7">More...</a><br /></td></tr>
<tr class="separator:aa67adb0b2215c44a4a770b6c36cfe8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68f79977567f2ffe11ea30631653dd8"><td class="memTemplParams" colspan="2"><a id="ac68f79977567f2ffe11ea30631653dd8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac68f79977567f2ffe11ea30631653dd8"><td class="memTemplItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_to64bit</b> (T v)</td></tr>
<tr class="separator:ac68f79977567f2ffe11ea30631653dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ee0d04356b216b1d04046c0e1b2d38"><td class="memTemplParams" colspan="2">template&lt;uint32_t Units, uint32_t Factor, uint32_t Prescale&gt; </td></tr>
<tr class="memitem:ae4ee0d04356b216b1d04046c0e1b2d38"><td class="memTemplItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d1f/namespaceclock.html#ae4ee0d04356b216b1d04046c0e1b2d38">units_to_time</a> ()</td></tr>
<tr class="memdesc:ae4ee0d04356b216b1d04046c0e1b2d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert "units" to real time units.  <a href="#ae4ee0d04356b216b1d04046c0e1b2d38">More...</a><br /></td></tr>
<tr class="separator:ae4ee0d04356b216b1d04046c0e1b2d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b5f264784ea96fd8629fec0c0f7131"><td class="memTemplParams" colspan="2">template&lt;uint32_t Time, uint32_t Factor, uint32_t Prescale&gt; </td></tr>
<tr class="memitem:ac6b5f264784ea96fd8629fec0c0f7131"><td class="memTemplItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d1f/namespaceclock.html#ac6b5f264784ea96fd8629fec0c0f7131">time_to_units</a> ()</td></tr>
<tr class="memdesc:ac6b5f264784ea96fd8629fec0c0f7131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert real time units to "units".  <a href="#ac6b5f264784ea96fd8629fec0c0f7131">More...</a><br /></td></tr>
<tr class="separator:ac6b5f264784ea96fd8629fec0c0f7131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadc978b0b25983f61b85b53ae468a51"><td class="memTemplParams" colspan="2">template&lt;uint32_t Factor, uint32_t Prescale = (uint32_t) _alibvr_clock_prescale::Prescale, typename T  = uint16_t&gt; </td></tr>
<tr class="memitem:afadc978b0b25983f61b85b53ae468a51"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d1f/namespaceclock.html#afadc978b0b25983f61b85b53ae468a51">units_to_time</a> (const T &amp;units)</td></tr>
<tr class="memdesc:afadc978b0b25983f61b85b53ae468a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert "units" to real time units.  <a href="#afadc978b0b25983f61b85b53ae468a51">More...</a><br /></td></tr>
<tr class="separator:afadc978b0b25983f61b85b53ae468a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fd6e3a91d0b307eeea0500d03d12fb"><td class="memTemplParams" colspan="2">template&lt;uint32_t Factor, uint32_t Prescale = (uint32_t) _alibvr_clock_prescale::Prescale, typename T  = uint16_t&gt; </td></tr>
<tr class="memitem:a46fd6e3a91d0b307eeea0500d03d12fb"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d1f/namespaceclock.html#a46fd6e3a91d0b307eeea0500d03d12fb">time_to_units</a> (const T &amp;n)</td></tr>
<tr class="memdesc:a46fd6e3a91d0b307eeea0500d03d12fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert real time units to "units".  <a href="#a46fd6e3a91d0b307eeea0500d03d12fb">More...</a><br /></td></tr>
<tr class="separator:a46fd6e3a91d0b307eeea0500d03d12fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5ca91b796d0c96b8094ba1441daedc"><td class="memTemplParams" colspan="2">template&lt;ClockSelect P = _alibvr_clock_prescale::Prescale, typename T  = uint16_t&gt; </td></tr>
<tr class="memitem:a2e5ca91b796d0c96b8094ba1441daedc"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d1f/namespaceclock.html#a2e5ca91b796d0c96b8094ba1441daedc">ms_to_units</a> (const T &amp;n)</td></tr>
<tr class="memdesc:a2e5ca91b796d0c96b8094ba1441daedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert ms to "units".  <a href="#a2e5ca91b796d0c96b8094ba1441daedc">More...</a><br /></td></tr>
<tr class="separator:a2e5ca91b796d0c96b8094ba1441daedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07c7dca2d34cd417aa968fa2ccab83b"><td class="memTemplParams" colspan="2">template&lt;ClockSelect P = _alibvr_clock_prescale::Prescale, typename T  = uint16_t&gt; </td></tr>
<tr class="memitem:ac07c7dca2d34cd417aa968fa2ccab83b"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d1f/namespaceclock.html#ac07c7dca2d34cd417aa968fa2ccab83b">us_to_units</a> (const T &amp;n)</td></tr>
<tr class="memdesc:ac07c7dca2d34cd417aa968fa2ccab83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert µs to "units".  <a href="#ac07c7dca2d34cd417aa968fa2ccab83b">More...</a><br /></td></tr>
<tr class="separator:ac07c7dca2d34cd417aa968fa2ccab83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b11929624655a5ac990b12829c8606"><td class="memTemplParams" colspan="2">template&lt;ClockSelect P = _alibvr_clock_prescale::Prescale, typename T  = uint16_t&gt; </td></tr>
<tr class="memitem:a64b11929624655a5ac990b12829c8606"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d1f/namespaceclock.html#a64b11929624655a5ac990b12829c8606">units_to_ms</a> (const T &amp;units)</td></tr>
<tr class="memdesc:a64b11929624655a5ac990b12829c8606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert "units" to ms.  <a href="#a64b11929624655a5ac990b12829c8606">More...</a><br /></td></tr>
<tr class="separator:a64b11929624655a5ac990b12829c8606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad223db3a13e650f8e16585cde9ff08ac"><td class="memTemplParams" colspan="2">template&lt;ClockSelect P = _alibvr_clock_prescale::Prescale, typename T  = uint16_t&gt; </td></tr>
<tr class="memitem:ad223db3a13e650f8e16585cde9ff08ac"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d1f/namespaceclock.html#ad223db3a13e650f8e16585cde9ff08ac">units_to_us</a> (const T &amp;units)</td></tr>
<tr class="memdesc:ad223db3a13e650f8e16585cde9ff08ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert "units" to µs.  <a href="#ad223db3a13e650f8e16585cde9ff08ac">More...</a><br /></td></tr>
<tr class="separator:ad223db3a13e650f8e16585cde9ff08ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae159a2e83f7b30eeafe3d5be8a3f5ef6"><td class="memTemplParams" colspan="2">template&lt;uint32_t Time, ClockSelect P = _alibvr_clock_prescale::Prescale&gt; </td></tr>
<tr class="memitem:ae159a2e83f7b30eeafe3d5be8a3f5ef6"><td class="memTemplItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d1f/namespaceclock.html#ae159a2e83f7b30eeafe3d5be8a3f5ef6">ms_to_units</a> ()</td></tr>
<tr class="memdesc:ae159a2e83f7b30eeafe3d5be8a3f5ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert ms to "units".  <a href="#ae159a2e83f7b30eeafe3d5be8a3f5ef6">More...</a><br /></td></tr>
<tr class="separator:ae159a2e83f7b30eeafe3d5be8a3f5ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058555acfdfbc406daf1cb9331b0bc6f"><td class="memTemplParams" colspan="2">template&lt;uint32_t Time, ClockSelect P = _alibvr_clock_prescale::Prescale&gt; </td></tr>
<tr class="memitem:a058555acfdfbc406daf1cb9331b0bc6f"><td class="memTemplItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d1f/namespaceclock.html#a058555acfdfbc406daf1cb9331b0bc6f">us_to_units</a> ()</td></tr>
<tr class="memdesc:a058555acfdfbc406daf1cb9331b0bc6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert µs to "units".  <a href="#a058555acfdfbc406daf1cb9331b0bc6f">More...</a><br /></td></tr>
<tr class="separator:a058555acfdfbc406daf1cb9331b0bc6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475b3551d89e7a345492a61f70830bd8"><td class="memTemplParams" colspan="2">template&lt;uint32_t Units, ClockSelect P = _alibvr_clock_prescale::Prescale&gt; </td></tr>
<tr class="memitem:a475b3551d89e7a345492a61f70830bd8"><td class="memTemplItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d1f/namespaceclock.html#a475b3551d89e7a345492a61f70830bd8">units_to_ms</a> ()</td></tr>
<tr class="memdesc:a475b3551d89e7a345492a61f70830bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert "units" to ms.  <a href="#a475b3551d89e7a345492a61f70830bd8">More...</a><br /></td></tr>
<tr class="separator:a475b3551d89e7a345492a61f70830bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320b3614df868e901b2f022f70a3d8ae"><td class="memTemplParams" colspan="2">template&lt;uint32_t Units, ClockSelect P = _alibvr_clock_prescale::Prescale&gt; </td></tr>
<tr class="memitem:a320b3614df868e901b2f022f70a3d8ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d1f/namespaceclock.html#a320b3614df868e901b2f022f70a3d8ae">units_to_us</a> ()</td></tr>
<tr class="memdesc:a320b3614df868e901b2f022f70a3d8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert "units" to µs.  <a href="#a320b3614df868e901b2f022f70a3d8ae">More...</a><br /></td></tr>
<tr class="separator:a320b3614df868e901b2f022f70a3d8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2818f7b058e27771426f39c7aa0365cd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a2818f7b058e27771426f39c7aa0365cd"><td class="memTemplItemLeft" align="right" valign="top">constexpr uint8_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d1f/namespaceclock.html#a2818f7b058e27771426f39c7aa0365cd">duration_passed</a> (const T &amp;previous_clock, const T &amp;current_clock, const U &amp;duration)</td></tr>
<tr class="memdesc:a2818f7b058e27771426f39c7aa0365cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate if the difference between previous_clock and current_clock is bigger than duration.  <a href="#a2818f7b058e27771426f39c7aa0365cd">More...</a><br /></td></tr>
<tr class="separator:a2818f7b058e27771426f39c7aa0365cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db26a90b5c001f2bb46af7a2069d63d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a4db26a90b5c001f2bb46af7a2069d63d"><td class="memTemplItemLeft" align="right" valign="top">constexpr uint8_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d1f/namespaceclock.html#a4db26a90b5c001f2bb46af7a2069d63d">duration_passed</a> (const T &amp;previous_clock, const U &amp;duration)</td></tr>
<tr class="memdesc:a4db26a90b5c001f2bb46af7a2069d63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate if duration has passed since previous_clock.  <a href="#a4db26a90b5c001f2bb46af7a2069d63d">More...</a><br /></td></tr>
<tr class="separator:a4db26a90b5c001f2bb46af7a2069d63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107ad02a77763be28bf63d43c566cf75"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a107ad02a77763be28bf63d43c566cf75"><td class="memTemplItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d1f/namespaceclock.html#a107ad02a77763be28bf63d43c566cf75">clock_reached</a> (const T &amp;clock, const T &amp;previous_clock, const T &amp;target_clock)</td></tr>
<tr class="memdesc:a107ad02a77763be28bf63d43c566cf75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate if target system clock has been reached.  <a href="#a107ad02a77763be28bf63d43c566cf75">More...</a><br /></td></tr>
<tr class="separator:a107ad02a77763be28bf63d43c566cf75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7a34ec30a2420b2b51e717ab02c400"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aae7a34ec30a2420b2b51e717ab02c400"><td class="memTemplItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d1f/namespaceclock.html#aae7a34ec30a2420b2b51e717ab02c400">clock_reached</a> (const T &amp;previous_clock, const T &amp;target_clock)</td></tr>
<tr class="memdesc:aae7a34ec30a2420b2b51e717ab02c400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate if target system clock has been reached.  <a href="#aae7a34ec30a2420b2b51e717ab02c400">More...</a><br /></td></tr>
<tr class="separator:aae7a34ec30a2420b2b51e717ab02c400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240d81de9119f92701aa5f26555972c4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a240d81de9119f92701aa5f26555972c4"><td class="memTemplItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d1f/namespaceclock.html#a240d81de9119f92701aa5f26555972c4">clock_reached</a> (const T &amp;target_clock)</td></tr>
<tr class="memdesc:a240d81de9119f92701aa5f26555972c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate if target system clock has been reached.  <a href="#a240d81de9119f92701aa5f26555972c4">More...</a><br /></td></tr>
<tr class="separator:a240d81de9119f92701aa5f26555972c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a0cfce972d3684eddb3dd61bb0baaf225"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="../../d6/db9/unionbits64__s.html">bits64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d1f/namespaceclock.html#a0cfce972d3684eddb3dd61bb0baaf225">_clock</a></td></tr>
<tr class="memdesc:a0cfce972d3684eddb3dd61bb0baaf225"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the system clock.  <a href="#a0cfce972d3684eddb3dd61bb0baaf225">More...</a><br /></td></tr>
<tr class="separator:a0cfce972d3684eddb3dd61bb0baaf225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8414359d2fd2b9f75143850c0e3bb4b5"><td class="memItemLeft" align="right" valign="top"><a id="a8414359d2fd2b9f75143850c0e3bb4b5"></a>
static <a class="el" href="../../d8/de9/classclock_1_1__Clock.html">_Clock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Clock</b></td></tr>
<tr class="separator:a8414359d2fd2b9f75143850c0e3bb4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file uses <code>Timer0</code> to provide a system clock. </p>
<p>By default class related classes, enums,... are defined inside the <code>clock</code> namespace. If this creates a name clash with your code you may modify the namespace name by setting ALIBVR_NAMESPACE_CLOCK or ALIBVR_NAMESPACE_PREFIX.</p>
<p>The system clock is derived from the IO-clock and must be converted to seconds.</p>
<p>Conversion functions are provided. Try to stay with the template versions, which can be calculated during compile time. Conversion of variables (with values unknown during compile time) will probably include division code, which is both big and slow.</p>
<p>It is usually possible to compare the difference of 2 time instances with a converted interval value:</p>
<p>Instead of (both examples in pseudocode):</p>
<div class="fragment"><div class="line">uint8_t clock1 = Clock;</div><div class="line"><span class="comment">// do something</span></div><div class="line">uint8_t duration = Clock - clock1;</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="../../d9/d1f/namespaceclock.html#a64b11929624655a5ac990b12829c8606">units_to_ms</a>(duration) &gt; 5) <span class="comment">// work took more than 5 ms</span></div></div><!-- fragment --><p>write</p>
<div class="fragment"><div class="line">uint8_t clock1 = Clock;</div><div class="line"><span class="comment">// do something</span></div><div class="line">uint8_t duration = Clock - clock1;</div><div class="line"><span class="keywordflow">if</span> (duration &gt; ms_to_units&lt;5&gt;()) <span class="comment">// work took more than 5 ms</span></div></div><!-- fragment --><p><em>Global irqs are enabled unless the macro: <code>ALIBVR_CLOCK_NO_GLOBAL_IRQ</code> or <code>ALIBVR_NO_GLOBAL_IRQ</code> is defined!</em> By including this header directly or indirectly global irqs are enabled because of a static constructor in this file!</p>
<p>The clock is incremented inside the <code>Timer0</code> overflow irq handler. To activate the registered irq handler add <code>#include REGISTER_IRQS</code> after your <code>main</code> section. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a107ad02a77763be28bf63d43c566cf75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a107ad02a77763be28bf63d43c566cf75">&sect;&nbsp;</a></span>clock_reached() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t clock::clock_reached </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>previous_clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>target_clock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate if target system clock has been reached. </p>
<p>In order for this function to work correctly the type of target_clock (which is a template argument) must be big enough:</p>
<p><em>The type of target_clock must be big enough to represent <code>previous_clock - clock</code>.</em></p>
<p>The previous_clock is necessary because all clock operations assume that the system clock may wrap.</p>
<p>clock_reached uses the same type for the system clock as the type of target_clock (which is a template argument).</p>
<p>The previous_clock argument allows us to determine if the system clock has wrapped. If the system clock is smaller than previous_clock wrapping has occured.</p>
<p>Notice that target_clock may also be a wrapped value. This means that target_clock may be smaller than previous_clock.</p>
<p>Simply imagine an infinite time line. To get a specific time instance, take the value modulo the size of the target_clock type.</p>
<p>For instance the system clock value 300 and the target_clock type uint8_t would result in <code>300 % 256</code>, which is 44.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type size used for clock comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clock</td><td>The system clock value we should compare target to. </td></tr>
    <tr><td class="paramname">previous_clock</td><td>Used to disambiguate wrapped clock values. (See function description.) </td></tr>
    <tr><td class="paramname">target_clock</td><td>The target system clock value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae7a34ec30a2420b2b51e717ab02c400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7a34ec30a2420b2b51e717ab02c400">&sect;&nbsp;</a></span>clock_reached() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t clock::clock_reached </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>previous_clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>target_clock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate if target system clock has been reached. </p>
<p>This function uses the current system clock as clock value.</p>
<p>In order for this function to work correctly the type of target_clock (which is a template argument) must be big enough:</p>
<p><em>The type of target_clock must be big enough to represent <code>previous_clock - clock</code>.</em></p>
<p>The previous_clock is necessary because all clock operations assume that the system clock may wrap.</p>
<p>clock_reached uses the same type for the system clock as the type of target_clock (which is a template argument).</p>
<p>The previous_clock argument allows us to determine if the system clock has wrapped. If the system clock is smaller than previous_clock wrapping has occured.</p>
<p>Notice that target_clock may also be a wrapped value. This means that target_clock may be smaller than previous_clock.</p>
<p>Simply imagine an infinite time line. To get a specific time instance, take the value modulo the size of the target_clock type.</p>
<p>For instance the system clock value 300 and the target_clock type uint8_t would result in <code>300 % 256</code>, which is 44.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type size used for clock comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">previous_clock</td><td>Used to disambiguate wrapped clock values. (See function description.) </td></tr>
    <tr><td class="paramname">target_clock</td><td>The target system clock value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a240d81de9119f92701aa5f26555972c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240d81de9119f92701aa5f26555972c4">&sect;&nbsp;</a></span>clock_reached() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t clock::clock_reached </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>target_clock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate if target system clock has been reached. </p>
<p>This function uses the current system clock as clock value and the current clock minus half the size of T as previous_clock.</p>
<p>E.g. if T is uint8_t the current system clock minus 128 is used as previous clock.</p>
<p>In order for this function to work correctly the type of target_clock (which is a template argument) must be big enough:</p>
<p><em>The type of target_clock must be big enough to represent <code>previous_clock - clock</code>.</em></p>
<p>The previous_clock is necessary because all clock operations assume that the system clock may wrap.</p>
<p>clock_reached uses the same type for the system clock as the type of target_clock (which is a template argument).</p>
<p>The previous_clock argument allows us to determine if the system clock has wrapped. If the system clock is smaller than previous_clock wrapping has occured.</p>
<p>Notice that target_clock may also be a wrapped value. This means that target_clock may be smaller than previous_clock.</p>
<p>Simply imagine an infinite time line. To get a specific time instance, take the value modulo the size of the target_clock type.</p>
<p>For instance the system clock value 300 and the target_clock type uint8_t would result in <code>300 % 256</code>, which is 44.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type size used for clock comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_clock</td><td>The target system clock value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa67adb0b2215c44a4a770b6c36cfe8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67adb0b2215c44a4a770b6c36cfe8a7">&sect;&nbsp;</a></span>ClockIrqTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clock::ClockIrqTask </td>
          <td>(</td>
          <td class="paramtype">_irqs::Irq&#160;</td>
          <td class="paramname"><em>I</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the Timer0 Overflow handler, which increments the system clock. </p>
<p>The compiler would generate less code, but execute more commands on average than this assembler version. </p>

</div>
</div>
<a id="a2818f7b058e27771426f39c7aa0365cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2818f7b058e27771426f39c7aa0365cd">&sect;&nbsp;</a></span>duration_passed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint8_t clock::duration_passed </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>previous_clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>current_clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate if the difference between previous_clock and current_clock is bigger than duration. </p>
<p>This function will return a correct result, even if Clock has wrapped around. It is however up to the caller to make sure that the clock type T is big enough.</p>
<p>Unless you have multiple comparisons with different durations, use the simpler duration_passed function, which only requires previous_clock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">previous_clock</td><td>The clock value (in "units") to which duration is added. It is ok if previous_clock equals current_clock. </td></tr>
    <tr><td class="paramname">current_clock</td><td>The clock value (in "units") which should be farther in the future than previous_clock + duration for this function to return true. </td></tr>
    <tr><td class="paramname">duration</td><td>The duration in "units" which should pass since previous_clock. See ms_to_units and us_to_units. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4db26a90b5c001f2bb46af7a2069d63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db26a90b5c001f2bb46af7a2069d63d">&sect;&nbsp;</a></span>duration_passed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint8_t clock::duration_passed </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>previous_clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate if duration has passed since previous_clock. </p>
<p>This function will return a correct result, even if Clock has wrapped around. It is however up to the caller to make sure that the clock type T is big enough.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">previous_clock</td><td>The clock value (in "units") to which duration is added. It is ok if previous_clock is the current Clock: <code>uint16_t prev = Clock; while (!duration_passed(prev, duration)) prev = Clock;</code> </td></tr>
    <tr><td class="paramname">duration</td><td>The duration in "units" which should pass since previous_clock. See ms_to_units and us_to_units. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e5ca91b796d0c96b8094ba1441daedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5ca91b796d0c96b8094ba1441daedc">&sect;&nbsp;</a></span>ms_to_units() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ClockSelect P = _alibvr_clock_prescale::Prescale, typename T  = uint16_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T clock::ms_to_units </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert ms to "units". </p>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Use template versions if possible.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The time duration in ms, which should be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">P</td><td>The prescale for <code>Timer0</code>. </td></tr>
    <tr><td class="paramname">T</td><td>The type of units (automatically determined). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae159a2e83f7b30eeafe3d5be8a3f5ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae159a2e83f7b30eeafe3d5be8a3f5ef6">&sect;&nbsp;</a></span>ms_to_units() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint32_t Time, ClockSelect P = _alibvr_clock_prescale::Prescale&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t clock::ms_to_units </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert ms to "units". </p>
<p>See units_to_time for an explaination why inputs are template arguments and why this isn't a constexpr function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Time</td><td>The time duration in ms, which should be converted. </td></tr>
    <tr><td class="paramname">P</td><td>The prescale for <code>Timer0</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6b5f264784ea96fd8629fec0c0f7131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b5f264784ea96fd8629fec0c0f7131">&sect;&nbsp;</a></span>time_to_units() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint32_t Time, uint32_t Factor, uint32_t Prescale&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t clock::time_to_units </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert real time units to "units". </p>
<p>See units_to_time for an explaination why inputs are template arguments and why this isn't a constexpr function.</p>
<p>See ms_to_units and us_to_units for functions with simplified input.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Time</td><td>The time duration, which should be converted. </td></tr>
    <tr><td class="paramname">Factor</td><td>Use 1 second / Factor as input unit. 1'000 for ms 1'000'000 for µs. </td></tr>
    <tr><td class="paramname">Prescale</td><td>The prescale for <code>Timer0</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46fd6e3a91d0b307eeea0500d03d12fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46fd6e3a91d0b307eeea0500d03d12fb">&sect;&nbsp;</a></span>time_to_units() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint32_t Factor, uint32_t Prescale = (uint32_t) _alibvr_clock_prescale::Prescale, typename T  = uint16_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t clock::time_to_units </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert real time units to "units". </p>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Use template versions if possible.</dd></dl>
<p>See units_to_ms and units_to_us for functions with simplified input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The time duration, which should be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Factor</td><td>Use 1 second / Factor as input unit. 1'000 for ms 1'000'000 for µs. </td></tr>
    <tr><td class="paramname">Prescale</td><td>The prescale for <code>Timer0</code>. </td></tr>
    <tr><td class="paramname">T</td><td>The type of units (automatically determined). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64b11929624655a5ac990b12829c8606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b11929624655a5ac990b12829c8606">&sect;&nbsp;</a></span>units_to_ms() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ClockSelect P = _alibvr_clock_prescale::Prescale, typename T  = uint16_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t clock::units_to_ms </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>units</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert "units" to ms. </p>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>Use template versions if possible.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td>The time duration in units, which should be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">P</td><td>The prescale for <code>Timer0</code>. </td></tr>
    <tr><td class="paramname">T</td><td>The type of units (automatically determined). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a475b3551d89e7a345492a61f70830bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475b3551d89e7a345492a61f70830bd8">&sect;&nbsp;</a></span>units_to_ms() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint32_t Units, ClockSelect P = _alibvr_clock_prescale::Prescale&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t clock::units_to_ms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert "units" to ms. </p>
<p>See units_to_time for an explaination why inputs are template arguments and why this isn't a constexpr function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Units</td><td>The units which should be converted. </td></tr>
    <tr><td class="paramname">P</td><td>The prescale for <code>Timer0</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4ee0d04356b216b1d04046c0e1b2d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ee0d04356b216b1d04046c0e1b2d38">&sect;&nbsp;</a></span>units_to_time() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint32_t Units, uint32_t Factor, uint32_t Prescale&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t clock::units_to_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert "units" to real time units. </p>
<p>All inputs are template arguments. This makes sure that the compiler will be able to calculate everything during compile time.</p>
<p>This is also possible with <code>constexpr</code> functions. However as a <code>constexpr</code> will work with dynamic values as well and not give any warning I prefer the template version as it makes sure that the inputs are known during compile time.</p>
<p>See units_to_ms and units_to_us for functions with simplified input.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Units</td><td>The system clock units, which should be converted. </td></tr>
    <tr><td class="paramname">Factor</td><td>Use 1 second / Factor as return unit. 1'000 for ms 1'000'000 for µs. </td></tr>
    <tr><td class="paramname">Prescale</td><td>The prescale for <code>Timer0</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afadc978b0b25983f61b85b53ae468a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afadc978b0b25983f61b85b53ae468a51">&sect;&nbsp;</a></span>units_to_time() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint32_t Factor, uint32_t Prescale = (uint32_t) _alibvr_clock_prescale::Prescale, typename T  = uint16_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t clock::units_to_time </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>units</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert "units" to real time units. </p>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Use template versions if possible.</dd></dl>
<p>See units_to_ms and units_to_us for functions with simplified input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td>The system clock units, which should be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Factor</td><td>Use 1 second / Factor as return unit. 1'000 for ms 1'000'000 for µs. </td></tr>
    <tr><td class="paramname">Prescale</td><td>The prescale for <code>Timer0</code>. </td></tr>
    <tr><td class="paramname">T</td><td>The type of units (automatically determined). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad223db3a13e650f8e16585cde9ff08ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad223db3a13e650f8e16585cde9ff08ac">&sect;&nbsp;</a></span>units_to_us() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ClockSelect P = _alibvr_clock_prescale::Prescale, typename T  = uint16_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t clock::units_to_us </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>units</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert "units" to µs. </p>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>Use template versions if possible.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td>The time duration in units, which should be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">P</td><td>The prescale for <code>Timer0</code>. </td></tr>
    <tr><td class="paramname">T</td><td>The type of units (automatically determined). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a320b3614df868e901b2f022f70a3d8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320b3614df868e901b2f022f70a3d8ae">&sect;&nbsp;</a></span>units_to_us() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint32_t Units, ClockSelect P = _alibvr_clock_prescale::Prescale&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t clock::units_to_us </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert "units" to µs. </p>
<p>See units_to_time for an explaination why inputs are template arguments and why this isn't a constexpr function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Units</td><td>The units which should be converted. </td></tr>
    <tr><td class="paramname">P</td><td>The prescale for <code>Timer0</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac07c7dca2d34cd417aa968fa2ccab83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac07c7dca2d34cd417aa968fa2ccab83b">&sect;&nbsp;</a></span>us_to_units() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ClockSelect P = _alibvr_clock_prescale::Prescale, typename T  = uint16_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t clock::us_to_units </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert µs to "units". </p>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Use template versions if possible.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The time duration in µs, which should be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">P</td><td>The prescale for <code>Timer0</code>. </td></tr>
    <tr><td class="paramname">T</td><td>The type of units (automatically determined). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a058555acfdfbc406daf1cb9331b0bc6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058555acfdfbc406daf1cb9331b0bc6f">&sect;&nbsp;</a></span>us_to_units() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint32_t Time, ClockSelect P = _alibvr_clock_prescale::Prescale&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t clock::us_to_units </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert µs to "units". </p>
<p>See units_to_time for an explaination why inputs are template arguments and why this isn't a constexpr function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Time</td><td>The time duration in µ, which should be converted. </td></tr>
    <tr><td class="paramname">P</td><td>The prescale for <code>Timer0</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a0cfce972d3684eddb3dd61bb0baaf225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfce972d3684eddb3dd61bb0baaf225">&sect;&nbsp;</a></span>_clock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="../../d6/db9/unionbits64__s.html">bits64_t</a> clock::_clock</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the system clock. </p>
<p>This variable is changed inside the <code>Timer0</code> overflow irq handler. <code>bits64_t</code> is a union type providing easy access to all bytes.</p>
<p>The prescaler is by default set to 1/64.</p><ul>
<li>At 8MHz _clock is incremented every 2'048ns.</li>
<li>At 1MHz _clock is incremented every 16'384ns.</li>
</ul>
<p>When retrieving the system clock the current <code>Timer0</code> counter is added. The precision of the system clock is therefore always cpu clock / prescaler. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
